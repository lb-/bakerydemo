{% load wagtailadmin_tags %}

<style>
    .collapsible .title-wrapper {
        box-sizing: border-box;
        cursor: pointer;
        height: 40px;
        background: #fcf2f2;
        color: #200200;
        padding: .9em 0 .9em 5em;
        font-size: .95em;
        margin: 0;
        line-height: 1.5em;
        font-weight: 400;
    }

    .collapsible .content {
        padding: 0 3rem;
    }

    .collapsible p {
        padding-top: 1rem;
    }

    .collapsible.collapsed .content {
        display: none;
    }

    .collapsible .title-wrapper::before {
        content: "▼";
    }

    .collapsible.collapsed .title-wrapper::before {
        content: "▲";
    }
</style>
<script>
document.addEventListener('wagtail:stimulus-init', function() {
    // see bakerydemo/ui/wagtail_hooks.py for where this event is fired

    const Application = window.wagtail.stimulus.Application;
    const Controller = window.wagtail.stimulus.Controller;

    // getControllerByIdentifier is not part of the built in stimulus API
    // added in wagtail hooks
    const Hello = window.wagtail.stimulus.getControllerByIdentifier('hello');

    /**
     * See bakerydemo/ui/wagtail_hooks.py for original `hello` definition.
     * Demo's the concept of a controller being imported
     */
    class Hello2 extends Hello {
        static targets = [ ...Hello.targets, 'other' ];

        doLog() {
          console.log('hello stimulus (2)', { element: this.element, label: this.labelValue });
        }

        connect() {
          super.connect();

          if (this.replaceValue) {
            this.element.innerText = this.labelValue;
          }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOMContentLoaded - registering replacement');
        Application.register("hello", Hello2);
    });
    

    Application.register('keyboard-shortcut', class extends Controller {
        static targets = [ 'element' ];
        static values = { command: { default: '', type: String } };

        connect() {
          // allow for single attribute use or for declaring a separate element
          // could be enhanced to update a 'global' register of keyboard shortcuts
          // best to use something like key-js or mousetrap if we actually do this
          const target = this.hasElementTarget ? this.elementTarget : this.element;
          this.keyboardListener = (event) => {
              if (event.key === this.commandValue) {
                  this.elementTarget.click(event);
              }
          };
          document.addEventListener('keyup', this.keyboardListener);
        }

        disconnect() {
            document.removeEventListener('keyup', this.keyboardListener);
        }
    });

    Application.register("collapsible", class extends Controller {
      static classes = [ "collapsed" ];
      static targets = [ "content", "title" ];
      static values = { collapsed: { default: false, type: Boolean }};

      connect() {
          // set up variables
          this.contentId = `${this.element.id || 'random-id-generated'}-content`;
          this.collapsedClassDefaulted = this.hasCollapsedClass ? this.collapsedClass: 'collapsed';

          // set up aria attributes
          this.element.setAttribute('aria-expanded', !this.collapsedValue);
          this.contentTarget.setAttribute('id', this.contentId);
          this.titleTarget.setAttribute('aria-controls', `#${this.contentId}`);
      }

      onAnimationComplete() {
          // 
      }

      collapsedValueChanged() {
          console.log('collapsed value changed');
      }

      toggle(event) {
        const collapsedClass = this.collapsedClassDefaulted;

        // toggle attributes
        this.collapsedValue = !this.collapsedValue;
        this.element.setAttribute('aria-expanded', !this.collapsedValue);

        // animations
        !this.collapsedValue && this.element.classList.remove(collapsedClass);
        const keyframes = { opacity: this.collapsedValue ? [1, 0] : [0, 1] };
        const animation = this.contentTarget.animate(keyframes, { duration: 500, easing: 'ease-out', fill: 'forwards' });
        animation.onfinish = () => {
            this.collapsedValue && this.element.classList.add(collapsedClass);
            this.onAnimationComplete();
        };
      }
    });

    /**
     * Purpose is to validate the behaviour of a controller that renders a React element.
     * That React element will also re-render when the 'values' are changed.
     * Also test the rendering of another controller item within the React tree.
     */
    class ReactTest extends Controller {
        static values = {
            data: { default: {}, type: Object },
            label: { default: 'Label', type: String, }
        };

        connect() {
            this.render();
        }

        dataValueChanged() {
            this.render();
        }

        labelValueChanged() {
            this.render();
        }

        render() {
            const data = this.dataValue;
            const { createElement } = window.React;
            const element = createElement('div', {
                children: [
                    createElement('strong', { children: `${this.labelValue}: ` , key: 'b' }),
                    createElement('span', {
                        'data-controller': "hello",
                        'data-hello-replace-value': 'true',
                        'data-hello-label-value': data.someVar,
                        children: `${data.someVar} (React)`,
                        // key: 'a', using a fixed key will mean that re-renders will be React children
                        key: data.someVar || 'a', // using a dynamic key will 're-mount' when the thing changes which will re-run the controller
                    }),
                ],
                className: 'react-injected'
            });
            ReactDOM.render(element, this.element);
        }
    }

    Application.register("react-test", ReactTest);

    /**
     * Purpose is to validate the behaviour of template tags that themselves contain other controllers
     * Plus see how template wrangling can look.
     */
    class TodoController extends Controller {

        static targets = [ 'addButton', 'items', 'newItemInput', 'template' ];

        connect() {
            // ensure the button disabled state gets in sync on load
            this.updateInput();
        }

        add() {
            const newItem = this.newItemInputTarget.value;
            if (!newItem) return;
            const newTodoItem = this.templateTarget.content.firstElementChild.cloneNode(true);
            newTodoItem.innerText = newItem;
            this.itemsTarget.appendChild(newTodoItem);
            this.newItemInputTarget.value = ''; // reset input
            this.updateInput(); // ensure the button disabled state gets in sync
        }

        updateInput() {
            // toggle the 'disabled' state of the add button when input added
            if (this.newItemInputTarget.value) {
                this.addButtonTarget.removeAttribute('disabled');
            } else {
                this.addButtonTarget.setAttribute('disabled','');
            }
        }

    }

    Application.register("todo", TodoController);

    /**
     * When fetch method is activated it will request the URL provided.
     * The result will be dispatched to an event on the controlled element as 'request:response'
     * */
    class RequestController extends Controller {
        static values = { 'url': String };

        fetch() {
            const dispatch = this.dispatch;

            fetch(this.urlValue).then(function(response) {
                return response.json();
            }).then((data) => {
                console.log('response resolved', data );
                this.element.querySelectorAll('.button-longrunning-active').forEach(element => {
                    element.removeAttribute('disabled');
                    element.classList.remove('button-longrunning-active');
                });
                this.dispatch("response", { detail: { data } });
            });
        }

    }

    /**
     * Contrived example to show two controllers working together via JS events.
     * When this controller's onResponse method is triggered it will update the container target
     * with some data from the result.
     * */
    class ActivityController extends Controller {
        static targets = ['container'];

        onResponse(event) {
            this.containerTarget.innerText = event.detail.data.activity;
        }

        reset() {
            this.containerTarget.innerText = '';
        }
    }

    /**
     * A POC replacement for button-longrunning
     * where, when clicked the button will show as loading (just disabled for now)
     * The stop (un-disable) can be triggered by another event globally.
     * Not sure if this is a good approach but a stopSelectorValue can be added to allow
     * for scoping the event.
     * 
     * For simple cases (where stopping the loading state does not matter), can be
     * <button data-controller="loading-button" data-action="loading-button#start">label</button>
     * 
     * Could be further enhanced to output the spinner icon, classes etc.
     * While the data-attributes may be longer, we could find a way to implement this
     * without declaring the icon each time.
     * */
    class LoadingButtonController extends Controller {

        static values = { stopSelector: {default: '*', type: String}};

        start() {
            this.element.setAttribute('disabled', '');
        }

        stop(event) {
            // only stop if the event's target matches the selector value
            // default is '*' so any event will match

            const stopSelectorValue = this.stopSelectorValue;
            if (event.target.matches(stopSelectorValue)) {
                this.element.removeAttribute('disabled');
            }
        }
    }

    Application.register("request", RequestController);
    Application.register("activity", ActivityController);
    Application.register("loading-button", LoadingButtonController);
});
</script>
<section class="panel">
    <h2>Hello world</h2>
    <div data-controller="hello"><span data-hello-target="other">Hello - second controller registered</span></div>
    <h2>Collapsible</h2>
    <section class="collapsible" data-controller="collapsible keyboard-shortcut" data-collapsible-collapsed-value="false" data-keyboard-shortcut-command-value="o">
        <h3 class="title-wrapper" data-collapsible-target="title" data-action="click->collapsible#toggle" data-keyboard-shortcut-target="element">About Stimulus JS</h3>
        <div class="content" data-collapsible-target="content">
            <p>Stimulus is a JavaScript framework with modest ambitions. It doesn’t seek to take over your entire front-end—in fact, it’s not concerned with rendering HTML at all. Instead, it’s designed to augment your HTML with just enough behavior to make it shine.</p>
            <section class="collapsible" data-controller="collapsible keyboard-shortcut" data-collapsible-collapsed-value="false" data-keyboard-shortcut-command-value="o">
                <h2 class="title-wrapper" data-collapsible-target="title" data-action="click->collapsible#toggle" data-keyboard-shortcut-target="element">About Stimulus JS</h2>
                <div class="content" data-collapsible-target="content">
                    <p>Stimulus is a JavaScript framework with modest ambitions. It doesn’t seek to take over your entire front-end—in fact, it’s not concerned with rendering HTML at all. Instead, it’s designed to augment your HTML with just enough behavior to make it shine.</p>
                </div>
            </section>
        </div>
    </section>
    <h3>React</h3>
    <div data-controller="react-test" data-react-test-data-value='{"someVar":"foo"}' data-react-test-label-value="Label supplied"></div>
    <h3>Todo</h3>
    <div data-controller="todo">
        <input type="text" placeholder="...check the mail" data-todo-target="newItemInput" data-action="todo#updateInput">
        <button class="button button-small" data-action="todo#add" data-todo-target="addButton" type="button" disabled>Add item</button>
        <ul data-todo-target="items">
            <li>Get milk</li>
            <li>Use a template tag</li>
        </ul>
        <template data-todo-target="template">
            <li data-controller="hello" data-hello-label-value="todo"></li>
        </template>
    </div>
    <h3>API with result passing via event to second controller</h3>
    <p>A contrived example where two controllers are used, one that makes the request and one that handles the response.</p>
    <article class="find-an-activity" data-controller="request activity" data-request-url-value="https://www.boredapi.com/api/activity" data-action="request:response->activity#onResponse">
        <button
            class="button button-small"
            data-action="request#fetch activity#reset loading-button#start request:response@document->loading-button#stop"
            data-controller="loading-button"
            data-loading-button-stop-selector-value=".find-an-activity"
            type="button"
        >
            Find something to do
        </button>
        <div data-activity-target="container">
        </div>
    </article>
</section>